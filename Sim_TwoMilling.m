clear;
close all;
clc;
% author: Jihao Liu
% date:   June 2022

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%%       0.1 Pre-set the milling planning parameters                      %
%                                                                         %
%  The number of layer and trajectory is generated by the geometrics.     %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% sensor
fr = 20;  % sensor sample frequency, unit: Hz

%% geometrics of milling bit
R = 2.0;                        % radius, unit: mm
betaG = pi/6;                   % helix angle, unit: rad
h = 0.3;                        % segment distance, unit: mm
flag = false;                   % flag - show the edge
num_teeth = 4;                  % the number of the teeth

params.R = R;                   % radius
params.betaG = betaG;           % helix angle
params.h = h;                   % segment distance
params.flag = flag;             % flag - show the edge
params.num_teeth = num_teeth;   % the number of the teeth

%% motion parameters
rpm = 800;                      % RPM, ...
w_v = rpm * 2 * pi / 60;        % rad/s, 800 rpm
vd  = 0.5;                      % mm/s

ft = vd/num_teeth/rpm*60;       % mm/teeth

%% milling trajectory
w = 1.5;           % distance beween adjacent trajectories on one layer, unit: mm
d = 0.8;           % the distance between layers, unit: mm

cState.w = w;          % distance beween adjacent trajectories on one layer
cState.d = d;          % the distance between layers
cState.R = R;          % the radius of the milling bit
cState.betaG = betaG;  % the helix angle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%%          0.2 Load a workspace from a CT image                          %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% load the related files 
data_nii = load_nii('verse620_CT-iso.nii');                  % original file
data2 = load_nii('sub-verse620_dir-iso_seg-vert_msk.nii');   % mask file for L2
data3 = load_nii('verse620_lam.nii');                        % mask file for lamin.

% get the resolution of nii-file
res = data_nii.hdr.dime.pixdim(2:4);
% get the gray img of the CT image
grayVolume =  data_nii.img;

% Get the location of the pcl (of L2) segmented from the seg.msk
loc_2 = SampleNiiSeg(data2, 22, 11);     % No figure show
% Get the location of the pcl (of lami..) segmented from the lami.msk
loc_3 = SampleNiiSeg(data3, 1, 1);     % No figure show

loc_3pt = pointCloud(loc_3,'color', ones(length(loc_3),1)*[1 0 0]);  % change the color by pointCloud.

% demo - the pcl of L2 with lami...
figure()
pcshow(loc_2);
hold on
% pcshow(loc_3);
pcshow(loc_3pt);
% hold on
view([1 -1 1])
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%%       0.3 Get a workspace filled with gray by planning                 %
%                                                                         %
%        % physical size, unit: mm                                        %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% the size of the workspace
Frame = [32.168, 8.9997, 9.1966];
% the center of the workspace works as the origine.
tran  = [0.13428, -0.91245, -0.38654, 106.04;
        -0.24615, -0.40856,  0.87891,  91.693;
        -0.95988, -0.02287, -0.27946, 183.55;
               0,        0,        0,      1];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%%        1.  produce the cutting edge on the half sphere.                %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
trajectoryLength = Frame(1) - 2*R;
trajectoryWidth  = Frame(2) - 2*R;
millingDepth     = Frame(3);

numPointLine    = floor(trajectoryLength / vd * fr);       % the number of sampling point of every trajectory
Num_Trajecotry  = floor(trajectoryWidth / w) + 1;   % the number of milling trajectories of every layer
Num_Layer       = floor(millingDepth / d);          % the number of milling layers

% Modify the frame size. The centor / origine of the workspace does not
% move. 
new_Frame     = zeros(size(Frame));
new_Frame(1)  = numPointLine / fr * vd;    % unit: mm
new_Frame(2)  = (Num_Trajecotry - 1) * w;  % unit: mm
new_Frame(3)  = Num_Layer * d;             % unit: mm

Ori_loc     = [-new_Frame/2 1] + [R, R, d, 0];    % the workspace original in the LCS (coordinate system of lam.)
Ori_wld     = tran*Ori_loc';                  % the workspace original in the WCS ()
tran_wld    = tran;                          % remodify the translation matrix.
tran_wld(1:3,4)  = Ori_wld(1:3,1);
% the tran_wld indicates the workspace coordinate system referring to the
% CT.

% produce the cutting edge
Points  = GenerateEdge2(params);             % [x, y, z, theta, phi] of edge element
points  = Points(1:3,:);                     % get the D-Position, [x, y, z] of the edge element
PCL     = [points; ones(1,length(Points))];    % tranlsate the data into the translation data
cen     = [0 0 0 1]';                          % the centroid of the milling bit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%%       2.  milling bit moves to the initial location.                   %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% the posture of milling rotation axis (MCS) in terms of the workpiece (WCS) 
RX   = ROX(pi/6);
RY   = ROY(0); % pi/10

phase_flag   = false;
%% given the initial phase for every milling trajectory
phase_init   = GenerateRandPhase(Num_Layer, Num_Trajecotry,phase_flag);

%%  calculate ...

delta_theta = 0.0710;             % for getting the valid edge, and area.
% d_l = R*delta_theta;

Fx = [];
Fy = [];
Fz = [];
M  = [];
gray = [];

Ft = [ft 0 0]';

% The tanslation matrix to the work_space ...
TM_gray = tran_wld;

for i = 1:Num_Layer
    cState.NumLayer = i;
%     i
    for j = 1:Num_Trajecotry
        cState.NumTrajectory = j;
%         j
        phase_rand = phase_init(i,j);
%         phase_init = [phase_init, phase_rand];

        temp_fx = [];
        temp_fy = [];
        temp_fz = [];
        temp_m  = [];
        temp_gray = [];
        
        count_show = 1;
        for k = 1:numPointLine
            % at a certain position.
            clock = k/fr;
            Vd = [vd * clock; w*(j-1); d*(i-1)];

            RZ = ROZ(clock*w_v + phase_rand);
            T_work = [RX*RY*RZ Vd; 0 0 0 1];
            PCL_cur = zeros(size(PCL));

            F_t = (RX*RY*RZ)\Ft;       % for t_n
            cState.F_t = F_t;          

            for m = 1:length(PCL)
                PCL_cur(:,m) = T_work * PCL(:,m);
            end
            cen_cur = T_work * cen;

            % produce the points on the 
            PCL_cur = [PCL_cur; Points(4:5,:)];
            PCLx = CuttingSurfaceX(PCL_cur,cen_cur);   % delete the half points
            valid_PCL = CWE(PCLx, cState);             % produce the parameter

            %%
            curr_cen = TM_gray * cen_cur;
            cen_pl = pointCloud(reshape(curr_cen(1:3), [1,3]), 'Color', [0.3 0.4 0.8]);
            hold on
            pcshow(cen_pl)

%             if count_show == 1
%                 temp_color = [0.2 1.0 0.3];
%                 ShowMillingEdge(valid_PCL, TM_gray, temp_color);
%             end
%             if count_show == 225
% %                 ShowMillingEdge(valid_PCL, TM_gray);
%                 count_show = 1;
%             else
%                 count_show = count_show + 1;
%             end

            %%
            mbForce = InstanceForceTran(valid_PCL, res, grayVolume, R, delta_theta, TM_gray);  % @ mbcs
            t_gray = GrayMeanTran(valid_PCL, res, grayVolume, TM_gray);                      %
            
            T_z = eye(4);
            T_z(1:3,1:3) = RZ;

            temp_force = T_z * mbForce;  % THIS IS SPECIAL CALCULATION NOT HOM.    % the force translated into TCS from the rotating MTCS

            temp_fx = [temp_fx temp_force(1)];
            temp_fy = [temp_fy temp_force(2)];
            temp_fz = [temp_fy temp_force(3)];
            temp_m  = [temp_m  temp_force(4)];
            temp_gray = [temp_gray t_gray];
        end   % data of every trajectory is produced

        % every row indicates predictions of one trajectory in the following various.
        Fx = [Fx; temp_fx];
        Fy = [Fy; temp_fy];
        Fz = [Fz; temp_fz];
        M  = [M;  temp_m];
        gray = [gray; temp_gray];
    end
end

% Simulation _ The tanslation matrix to the work_space ...
Sim_Tran = RandInitPoint()*tran_wld;

sim_Fx = [];
sim_Fy = [];
sim_Fz = [];
sim_M  = [];
sim_gray = [];

for i = 1:Num_Layer
    cState.NumLayer = i;
%     i
    for j = 1:Num_Trajecotry
        cState.NumTrajectory = j;
%         j
        phase_rand = phase_init(i,j);
%         phase_init = [phase_init, phase_rand];

        temp_fx = [];
        temp_fy = [];
        temp_fz = [];
        temp_m  = [];
        temp_gray = [];
        
        count_show = 1;
        for k = 1:numPointLine
            % at a certain position.
            clock = k/fr;
            Vd = [vd * clock; w*(j-1); d*(i-1)];

            RZ = ROZ(clock*w_v + phase_rand);
            T_work = [RX*RY*RZ Vd; 0 0 0 1];
            PCL_cur = zeros(size(PCL));

            F_t = (RX*RY*RZ)\Ft;       % for t_n
            cState.F_t = F_t;          

            for m = 1:length(PCL)
                PCL_cur(:,m) = T_work * PCL(:,m);
            end
            cen_cur = T_work * cen;

            % produce the points on the 
            PCL_cur = [PCL_cur; Points(4:5,:)];
            PCLx = CuttingSurfaceX(PCL_cur,cen_cur);   % delete the half points
            valid_PCL = CWE(PCLx, cState);             % produce the parameter

            %%
            if count_show == 1
                cu

            curr_cen = TM_gray * cen_cur;
            cen_pl = pointCloud(reshape(curr_cen(1:3), [1,3]), 'Color', [0.7 0.5 0.4]);
            hold on
            pcshow(cen_pl)

%             if count_show == 1
%                 tempColor = [0.8 0.4 0.2];
%                 ShowMillingEdge(valid_PCL, Sim_Tran, tempColor);
%             end
%             if count_show == 225
% %                 ShowMillingEdge(valid_PCL, TM_gray);
%                 count_show = 1;
%             else
%                 count_show = count_show + 1;
%             end

            %%
            mbForce = InstanceForceTran(valid_PCL, res, grayVolume, R, delta_theta, Sim_Tran);  % @ mbcs
            t_gray = GrayMeanTran(valid_PCL, res, grayVolume, Sim_Tran);                      %
            
            T_z = eye(4);
            T_z(1:3,1:3) = RZ;

            temp_force = T_z * mbForce;  % THIS IS SPECIAL CALCULATION NOT HOM.    % the force translated into TCS from the rotating MTCS

            temp_fx = [temp_fx temp_force(1)];
            temp_fy = [temp_fy temp_force(2)];
            temp_fz = [temp_fy temp_force(3)];
            temp_m  = [temp_m  temp_force(4)];
            temp_gray = [temp_gray t_gray];
        end   % data of every trajectory is produced

        % every row indicates predictions of one trajectory in the following various.
        sim_Fx = [sim_Fx; temp_fx];
        sim_Fy = [sim_Fy; temp_fy];
        sim_Fz = [sim_Fz; temp_fz];
        sim_M  = [sim_M;  temp_m];
        sim_gray = [sim_gray; temp_gray];
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[tra_num, sample_num] = size(Fx);

Time_scale = [1:sample_num]/fr;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% gray analysis
%
gray_mean = mean(gray,2);
gray_max = max(gray,[],2);
gray_min = min(gray,[],2);
figure()
plot(gray_mean);
hold on
plot(gray_max, 'ro')
plot(gray_min, 'ro')
hold off

figure()
imagesc(CM_gray>0.5);
title('Gray - 0.5')
colorbar;

figure()
imagesc(CM_gray>0.4);
title('Gray - 0.4')
colorbar;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for index_i = 1: tra_num
    len = 75;
    num_element = floor(numPointLine/len);
    co_fx = zeros(num_element,1);
    co_fy = zeros(num_element,1);
    co_fz = zeros(num_element,1);
    co_m = zeros(num_element,1);
    
    simi_fx  = zeros(num_element,1);
    simi_fy  = zeros(num_element,1);
    simi_fz  = zeros(num_element,1);
    simi_m  = zeros(num_element,1);
    
    for index_j = 1:num_element
        temp = corrcoef(gray(index_i,(index_j-1)*len+1:index_j*len),Fx(index_i,(index_j-1)*len+1:index_j*len));
        co_fx(index_j) = abs(temp(2));

        temp = corrcoef(gray(index_i,(index_j-1)*len+1:index_j*len),Fy(index_i,(index_j-1)*len+1:index_j*len));
        co_fy(index_j) = abs(temp(2));
        
        temp = corrcoef(gray(index_i,(index_j-1)*len+1:index_j*len),Fz(index_i,(index_j-1)*len+1:index_j*len));
        co_fz(index_j) = abs(temp(2));
        
        temp = corrcoef(gray(index_i,(index_j-1)*len+1:index_j*len),M(index_i,(index_j-1)*len+1:index_j*len));
        co_m(index_j) = abs(temp(2));
        
        simi_fx(index_j) = dtw(gray(index_i,(index_j-1)*len+1:index_j*len),Fx(index_i,(index_j-1)*len+1:index_j*len));
        simi_fy(index_j) = dtw(gray(index_i,(index_j-1)*len+1:index_j*len),Fy(index_i,(index_j-1)*len+1:index_j*len));
        simi_fz(index_j) = dtw(gray(index_i,(index_j-1)*len+1:index_j*len),Fz(index_i,(index_j-1)*len+1:index_j*len));
        simi_m(index_j) = dtw(gray(index_i,(index_j-1)*len+1:index_j*len),M(index_i,(index_j-1)*len+1:index_j*len));
    end


    figure()
    subplot(4,2,1)
    plot(co_fx)
    temp_title = strcat('COOE-Fx-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,2)
    plot(co_fy)
    temp_title = strcat('COOE-Fy-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,3)
    plot(co_fz)
    temp_title = strcat('COOE-Fz-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,4)
    plot(co_m)
    temp_title = strcat('COOE-Mz-',num2str(index_i));
    title(temp_title)
    colorbar

    subplot(4,2,5)
    plot(simi_fx)
    temp_title = strcat('SIMI-Fx-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,6)
    plot(simi_fy)
    temp_title = strcat('SIMI-Fy-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,7)
    plot(simi_fz)
    temp_title = strcat('SIMI-Fz-',num2str(index_i));
    title(temp_title)
    colorbar
    subplot(4,2,8)
    plot(simi_m)
    temp_title = strcat('SIMI-Mz-',num2str(index_i));
    title(temp_title)
    colorbar

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% coorcoef analysis
%
CM_fx = zeros(tra_num);
CM_fy = zeros(tra_num);
CM_fz = zeros(tra_num);
CM_m = zeros(tra_num);
CM_gray = zeros(tra_num);

for i = 1:tra_num
    for j = i:tra_num
        co_ef = corrcoef(Fx(i,:),Fx(j,:));
        CM_fx(i,j) = abs(co_ef(2));
        CM_fx(j,i) = abs(co_ef(2));

        co_ef = corrcoef(Fy(i,:),Fy(j,:));
        CM_fy(i,j) = abs(co_ef(2));
        CM_fy(j,i) = abs(co_ef(2));

        co_ef = corrcoef(Fz(i,:),Fz(j,:));
        CM_fz(i,j) = abs(co_ef(2));
        CM_fz(j,i) = abs(co_ef(2));

        co_ef = corrcoef(M(i,:),M(j,:));
        CM_m(i,j) = abs(co_ef(2));
        CM_m(j,i) = abs(co_ef(2));

        co_ef = corrcoef(gray(i,:),gray(j,:));
        CM_gray(i,j) = abs(co_ef(2));
        CM_gray(j,i) = abs(co_ef(2));
    end
end

index = 1;
figure()
for i = 1:Num_Layer
    for j = 1:Num_Trajecotry
        subplot(i,j,index)
        plot(gray(index,:));
        index = index + 1;
    end
end


figure()
subplot(2,2,1)
imagesc(CM_fx);
title('Fx')
colorbar;
subplot(2,2,2)
imagesc(CM_fy);
title('Fy')
colorbar;
subplot(2,2,3)
imagesc(CM_fz);
title('Fz')
colorbar;subplot(2,2,4)
imagesc(CM_m);
title('Mz')
colorbar;

figure()
imagesc(CM_gray);
title('Gray')
colorbar;
%
%% similiarity analysis based on DTW
%
SM_fx = zeros(tra_num);
SM_fy = zeros(tra_num);
SM_fz = zeros(tra_num);
SM_m = zeros(tra_num);
SM_gray = zeros(tra_num);

for i = 1:tra_num
    for j = i:tra_num
        SM_fx(i,j) = dtw(Fx(i,:),Fx(j,:));
        SM_fx(j,i) = SM_fx(i,j);

        SM_fy(i,j) = dtw(Fy(i,:),Fy(j,:));
        SM_fy(j,i) = SM_fy(i,j);

        SM_fz(i,j) = dtw(Fz(i,:),Fz(j,:));
        SM_fz(j,i) = SM_fz(i,j);

        SM_m(i,j) = dtw(M(i,:),M(j,:));
        SM_m(j,i) = SM_m(i,j);

        SM_gray(i,j) = dtw(gray(i,:),gray(j,:));
        SM_gray(j,i) = SM_gray(i,j);
    end
end

figure()
subplot(2,2,1)
imagesc(SM_fx);
title('Fx')
colorbar;
subplot(2,2,2)
imagesc(SM_fy);
title('Fy')
colorbar;
subplot(2,2,3)
imagesc(SM_fz);
title('Fz')
colorbar;subplot(2,2,4)
imagesc(SM_m);
title('Mz')
colorbar;

figure()
imagesc(SM_gray);
title('Gray')
colorbar;

%
%% similiarity analysis based on DTW
%

for i = 1:3:tra_num
    for j = i:3:tra_num
        len = 75;
        num_element = floor(numPointLine/len);

        cmFx = zeros(num_element);
        cmFy = zeros(num_element);
        cmFz = zeros(num_element);
        cmM = zeros(num_element);
        cmg = zeros(num_element);

        smFx = zeros(num_element);
        smFy = zeros(num_element);
        smFz = zeros(num_element);
        smM = zeros(num_element);
        smg = zeros(num_element);

        for inx_i = 1:num_element
            for inx_j = 1:num_element
                
                co_ef = corrcoef(Fx(i,len*(inx_i-1)+1:len*inx_i), Fx(j,len*(inx_j-1)+1:len*inx_j));
                cmFx(inx_i, inx_j) = abs(co_ef(2));

                co_ef = corrcoef(Fy(i,len*(inx_i-1)+1:len*inx_i), Fy(j,len*(inx_j-1)+1:len*inx_j));
                cmFy(inx_i, inx_j) = abs(co_ef(2));

                co_ef = corrcoef(Fz(i,len*(inx_i-1)+1:len*inx_i), Fz(j,len*(inx_j-1)+1:len*inx_j));
                cmFz(inx_i, inx_j) = abs(co_ef(2));

                co_ef = corrcoef(M(i,len*(inx_i-1)+1:len*inx_i), M(j,len*(inx_j-1)+1:len*inx_j));
                cmM(inx_i, inx_j) = abs(co_ef(2));

                co_ef = corrcoef(gray(i,len*(inx_i-1)+1:len*inx_i), gray(j,len*(inx_j-1)+1:len*inx_j));
                cmg(inx_i, inx_j) = abs(co_ef(2));

                %%%%%%%%%%%%%%%%%%%%%%%%

                smFx(inx_i, inx_j) = dtw(Fx(i,len*(inx_i-1)+1:len*inx_i), Fx(j,len*(inx_j-1)+1:len*inx_j));
                smFy(inx_i, inx_j) = dtw(Fy(i,len*(inx_i-1)+1:len*inx_i), Fy(j,len*(inx_j-1)+1:len*inx_j));
                smFz(inx_i, inx_j) = dtw(Fz(i,len*(inx_i-1)+1:len*inx_i), Fz(j,len*(inx_j-1)+1:len*inx_j));
                smM(inx_i, inx_j) = dtw(M(i,len*(inx_i-1)+1:len*inx_i), M(j,len*(inx_j-1)+1:len*inx_j));
                smg(inx_i, inx_j) = dtw(gray(i,len*(inx_i-1)+1:len*inx_i), gray(j,len*(inx_j-1)+1:len*inx_j));

            end
        end

        figure()
        subplot(3,2,1)
        imagesc(cmFx);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fx');
        title(title_tmp)
        colorbar;
        subplot(3,2,2)
        imagesc(cmFy);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fy');
        title(title_tmp)
        colorbar;
        subplot(3,2,3)
        imagesc(cmFz);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fz');
        title(title_tmp)
        colorbar;
        subplot(3,2,4)
        imagesc(cmM);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Mz');
        title(title_tmp)
        colorbar;
        subplot(3,2,5)
        imagesc(cmg);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' gray');
        title(title_tmp)
        colorbar;

        figure()
        subplot(3,2,1)
        imagesc(smFx);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fx');
        title(title_tmp)
        colorbar;
        subplot(3,2,2)
        imagesc(smFy);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fy');
        title(title_tmp)
        colorbar;
        subplot(3,2,3)
        imagesc(smFz);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Fz');
        title(title_tmp)
        colorbar;
        subplot(3,2,4)
        imagesc(smM);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' Mz');
        title(title_tmp)
        colorbar;
        subplot(3,2,5)
        imagesc(smg);
        temp = strcat(strcat(num2str(i),'-'),num2str(j));
        title_tmp = strcat(temp,' gray');
        title(title_tmp)
        colorbar;
    end
end

save MillingSim_1.mat w d numPointLine Num_Layer Num_Trajecotry Fx Fy Fz M gray % smFx smFy smFz smM smg

% show the figure ()

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% arbitrary lines
%










